# A/B Test Server Routing Documentation

## Overview

This document describes the server-side routing behavior required for A/B QR Code Split-Testing. The iOS app generates unique URLs for each variant, and the server must handle routing, tracking, and redirection.

## URL Format

### Variant URLs

- **Variant A**: `https://flyr.app/q/<slug>?variant=A`
- **Variant B**: `https://flyr.app/q/<slug>?variant=B`

Where `<slug>` is a unique URL-safe identifier generated by the iOS app (stored in `experiment_variants.url_slug`).

## Server Routing Logic

### Request Flow

1. **Receive Request**: Server receives GET request to `https://flyr.app/q/<slug>?variant=A` (or B)
2. **Find Experiment**: Query `experiment_variants` table by `url_slug` to find the variant
3. **Find Experiment**: Join to `experiments` table to get experiment details
4. **Get Landing Page**: Join to `landing_pages` table to get redirect URL
5. **Track Scan Event**: Insert row into `qr_scan_events` table
6. **Redirect**: HTTP 302 redirect to landing page URL

### Database Queries

```sql
-- Find variant and experiment
SELECT 
    ev.id as variant_id,
    ev.experiment_id,
    ev.key as variant_key,
    e.campaign_id,
    e.landing_page_id,
    lp.url as landing_page_url
FROM experiment_variants ev
JOIN experiments e ON e.id = ev.experiment_id
JOIN landing_pages lp ON lp.id = e.landing_page_id
WHERE ev.url_slug = :slug
AND ev.key = :variant_key; -- 'A' or 'B'
```

### Track Scan Event

```sql
INSERT INTO qr_scan_events (
    experiment_id,
    variant_id,
    campaign_id,
    landing_page_id,
    device_type,
    city,
    created_at
) VALUES (
    :experiment_id,
    :variant_id,
    :campaign_id,
    :landing_page_id,
    :device_type,  -- Extract from User-Agent header
    :city,         -- Optional: Extract from IP geolocation (generalized)
    NOW()
);
```

## Implementation Options

### Option 1: Supabase Edge Function

Create a Supabase Edge Function at `/functions/qr_redirect/index.ts`:

```typescript
import { serve } from "https://deno.land/std@0.168.0/http/server.ts"
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2'

serve(async (req) => {
  const url = new URL(req.url)
  const slug = url.pathname.split('/q/')[1]?.split('?')[0]
  const variant = url.searchParams.get('variant')
  
  if (!slug || !variant) {
    return new Response('Invalid URL', { status: 400 })
  }
  
  const supabase = createClient(
    Deno.env.get('SUPABASE_URL') ?? '',
    Deno.env.get('SUPABASE_SERVICE_ROLE_KEY') ?? ''
  )
  
  // Find variant and experiment
  const { data: variantData, error } = await supabase
    .from('experiment_variants')
    .select(`
      id,
      experiment_id,
      key,
      experiments!inner(
        id,
        campaign_id,
        landing_page_id,
        landing_pages!inner(url)
      )
    `)
    .eq('url_slug', slug)
    .eq('key', variant)
    .single()
  
  if (error || !variantData) {
    return new Response('Variant not found', { status: 404 })
  }
  
  const experiment = variantData.experiments
  const landingPageUrl = experiment.landing_pages.url
  
  // Extract device info from User-Agent
  const userAgent = req.headers.get('user-agent') || ''
  const deviceType = extractDeviceType(userAgent)
  
  // Track scan event
  await supabase
    .from('qr_scan_events')
    .insert({
      experiment_id: experiment.id,
      variant_id: variantData.id,
      campaign_id: experiment.campaign_id,
      landing_page_id: experiment.landing_page_id,
      device_type: deviceType,
      city: null, // Optional: Add IP geolocation
      created_at: new Date().toISOString()
    })
  
  // Redirect to landing page
  return Response.redirect(landingPageUrl, 302)
})

function extractDeviceType(userAgent: string): string {
  if (/mobile|android|iphone|ipad/i.test(userAgent)) {
    return 'mobile'
  }
  return 'desktop'
}
```

### Option 2: Vercel Middleware

Create `middleware.ts` in your Vercel project:

```typescript
import { NextResponse } from 'next/server'
import type { NextRequest } from 'next/server'

export async function middleware(request: NextRequest) {
  const path = request.nextUrl.pathname
  
  if (path.startsWith('/q/')) {
    const slug = path.split('/q/')[1]?.split('?')[0]
    const variant = request.nextUrl.searchParams.get('variant')
    
    if (!slug || !variant) {
      return NextResponse.redirect(new URL('/404', request.url))
    }
    
    // Query Supabase for variant and landing page
    // Track scan event
    // Redirect to landing page
    
    return NextResponse.redirect(landingPageUrl, 302)
  }
  
  return NextResponse.next()
}
```

### Option 3: Node.js/Express Microservice

Create a dedicated microservice for QR routing:

```javascript
const express = require('express')
const { createClient } = require('@supabase/supabase-js')
const app = express()

app.get('/q/:slug', async (req, res) => {
  const { slug } = req.params
  const variant = req.query.variant
  
  // Query database, track event, redirect
  // Similar logic to Edge Function above
})

app.listen(3000)
```

## Error Handling

### Invalid Slug

- Return HTTP 404 with user-friendly message
- Log error for monitoring

### Missing Variant Parameter

- Return HTTP 400 Bad Request
- Could redirect to default variant or experiment landing page

### Experiment Not Found

- Return HTTP 404
- Log for investigation (may indicate data inconsistency)

## Performance Considerations

1. **Caching**: Consider caching variant → landing page mappings (Redis/Memory)
2. **Database Indexes**: Ensure indexes on `experiment_variants.url_slug` (already created in migration)
3. **Async Tracking**: Consider async/background job for scan event insertion to reduce latency
4. **Rate Limiting**: Implement rate limiting to prevent abuse

## Security Considerations

1. **Input Validation**: Validate slug format (alphanumeric, URL-safe)
2. **SQL Injection**: Use parameterized queries (Supabase client handles this)
3. **Rate Limiting**: Prevent abuse of scan tracking
4. **Privacy**: City geolocation should be generalized (not exact coordinates)

## Testing

### Test Cases

1. Valid Variant A URL → Redirects to landing page, event tracked
2. Valid Variant B URL → Redirects to landing page, event tracked
3. Invalid slug → Returns 404
4. Missing variant parameter → Returns 400 or handles gracefully
5. Non-existent experiment → Returns 404
6. Multiple requests → Each tracked separately

### Manual Testing

```bash
# Test Variant A
curl -I "https://flyr.app/q/abc123def456?variant=A"

# Test Variant B
curl -I "https://flyr.app/q/abc123def456?variant=B"

# Test invalid slug
curl -I "https://flyr.app/q/invalid?variant=A"
```

## Future Enhancements

1. **Conversion Tracking**: Add webhook/API endpoint for landing page to report conversions
2. **Real-time Analytics**: WebSocket updates for live experiment stats
3. **A/B Test Automation**: Auto-complete experiments based on statistical significance
4. **Multi-variant Support**: Support for A/B/C/D tests (currently only A/B)

## Notes

- The iOS app generates slugs and URLs, but does not handle routing
- All routing logic must be implemented server-side
- Scan events are tracked server-side for accuracy
- Landing page URLs are stored in `landing_pages` table and can be updated independently

